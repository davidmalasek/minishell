âœ… SHELL SYMBOLS â€” EXPLAINED

â¸»

ğŸ”¹ ' (Single Quotes)

Purpose: Prevent all expansions and substitutions inside.

echo 'Hello $USER'
# Output: Hello $USER  â† No variable expansion

Behavior:
	â€¢	Everything inside '...' is taken literally.
	â€¢	You cannot escape characters inside single quotes.

Your shell must:
	â€¢	Treat the content inside as one literal token.
	â€¢	Do not expand variables or interpret special characters inside.

â¸»

ğŸ”¹ " (Double Quotes)

Purpose: Allow some expansion (like $VAR), but prevent word splitting and globbing.

echo "Hello $USER"
# Output: Hello tomas   â† Variable is expanded

echo "File: *"
# Output: File: *       â† No globbing (* is not expanded)

Behavior:
	â€¢	Variable expansion ($USER) and backslash escaping still work.
	â€¢	But itâ€™s treated as one token (no splitting by spaces inside).

Your shell must:
	â€¢	Recognize variable names inside.
	â€¢	Replace them with their values during parsing/lexing.
	â€¢	Keep the quoted content as a single token.

â¸»

ğŸ”¹ < and << (Input Redirection)

Symbol	Meaning
<	Redirects input from a file
<<	â€œHere documentâ€ â€” lets you input multiline strings directly in the shell

Example: <

cat < file.txt
# Equivalent to: open file.txt and feed it to cat via stdin

Example: << (Here-document)

cat << END
Hello
World
END

This will feed "Hello\nWorld\n" as input to cat.

Your shell must:
	â€¢	Recognize < and open the file, using dup2() to replace stdin.
	â€¢	Recognize << and read input lines until the delimiter is reached.

â¸»

ğŸ”¹ > and >> (Output Redirection)

Symbol	Meaning
>	Redirect output to a file (overwrite)
>>	Append output to a file

echo hello > file.txt   # file.txt contains "hello"
echo again >> file.txt  # file.txt now has "hello\nagain"

Your shell must:
	â€¢	Open the file in write or append mode.
	â€¢	Use dup2() to redirect stdout to the file before running the command.

â¸»

ğŸ”¹ | (Pipe)

Purpose: Connect the output of one command to the input of another.

ls | grep "test"

	â€¢	ls writes to a pipe instead of the terminal.
	â€¢	grep reads from that pipe instead of from stdin.

Your shell must:
	â€¢	Create a pipe with pipe()
	â€¢	Fork twice:
	â€¢	The first child writes to the pipe.
	â€¢	The second child reads from the pipe.
	â€¢	Use dup2() to redirect the stdout of the first and stdin of the second.

â¸»

ğŸ”¹ $ (Variable Expansion)

Purpose: Substitute variables with their values.

echo $USER
# Output: tomas

Your shell must:
	â€¢	Detect $ in the input string.
	â€¢	Find the matching variable name (e.g., USER).
	â€¢	Look it up in the environment.
	â€¢	Replace $USER with its value before executing the command.

â¸»

ğŸ”¹ $? (Last Command Exit Status)

Purpose: Gives the return code of the most recently executed command.

ls
echo $?
# Output: 0  â† if ls succeeded

ls nonexisting
echo $?
# Output: 1 or other non-zero value

Your shell must:
	â€¢	Store the return value of the last command (waitpid() gives it).
	â€¢	Replace $? with that numeric value during variable expansion.

â¸»

ğŸ§  TL;DR â€“ What You Must Implement

Symbol	What To Do
'...'	Treat contents as literal text (no expansion)
"..."	Allow variable expansion, but no splitting/globbing
<, <<	Redirect stdin (file or heredoc)
>, >>	Redirect stdout (overwrite or append)
`	`
$VAR	Replace with environment variable value
$?	Replace with last commandâ€™s exit status